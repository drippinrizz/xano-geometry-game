<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xano Dash - Geometry Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }
        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .game-title {
            font-size: 2.5em;
            color: #00f5ff;
            text-shadow: 0 0 20px #00f5ff, 0 0 40px #00f5ff;
            margin: 0;
        }
        .game-subtitle {
            font-size: 1.2em;
            color: #ff6b6b;
            margin: 5px 0;
        }
        .tagline {
            font-size: 0.9em;
            color: #4ecdc4;
            font-style: italic;
        }
        canvas {
            border: 2px solid #00f5ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.5), 0 0 60px rgba(0, 245, 255, 0.3);
            background: #0a0a0a;
        }
        .controls {
            margin-top: 15px;
            text-align: center;
            font-size: 0.9em;
            color: #aaa;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
            text-align: center;
            display: none;
        }
        .backend-joke {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            font-size: 0.8em;
            max-width: 600px;
            text-align: center;
        }
        .auth-section {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .auth-btn, .leaderboard-btn {
            padding: 8px 16px;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid #00f5ff;
            border-radius: 5px;
            color: #00f5ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
        }
        .auth-btn:hover, .leaderboard-btn:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00f5ff;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.5);
            min-width: 400px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal h2 {
            color: #00f5ff;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #00f5ff;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            color: #4ecdc4;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .form-group input {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00f5ff;
            border-radius: 5px;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .form-group input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        .modal-btn.primary {
            background: #00f5ff;
            color: #000;
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
        }
        .modal-btn.primary:hover {
            background: #4ecdc4;
            box-shadow: 0 0 25px rgba(0, 245, 255, 0.7);
        }
        .modal-btn.secondary {
            background: transparent;
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }
        .modal-btn.secondary:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        .user-info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4ecdc4;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.3);
        }
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .leaderboard-table th,
        .leaderboard-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }
        .leaderboard-table th {
            color: #00f5ff;
            font-weight: bold;
        }
        .leaderboard-table td {
            color: #fff;
        }
        .leaderboard-table tr:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .error-message {
            color: #ff6b6b;
            font-size: 0.8em;
            margin-top: 5px;
            text-align: center;
        }
        .loading-spinner {
            border: 2px solid rgba(0, 245, 255, 0.2);
            border-radius: 50%;
            border-top: 2px solid #00f5ff;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #4ecdc4;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
        }
        .death-animation {
            animation: deathShake 0.5s ease-in-out;
        }
        @keyframes deathShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        .new-high-score {
            color: #ffd700 !important;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700;
            animation: pulseGold 1s ease-in-out infinite;
        }
        @keyframes pulseGold {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <!-- Authentication Section -->
    <div class="auth-section" id="authSection">
        <button class="auth-btn" onclick="showLoginModal()">Login</button>
        <button class="auth-btn" onclick="showSignupModal()">Sign Up</button>
    </div>

    <!-- Leaderboard Button -->
    <div class="auth-section" id="leaderboardBtnContainer" style="top: 70px; right: 20px; position: fixed; z-index: 1000; display: flex;">
        <button class="leaderboard-btn" onclick="showLeaderboard()">üèÜ Leaderboard</button>
    </div>

    <!-- User Info -->
    <div class="user-info" id="userInfo" style="display: none;">
        <div>üë®‚Äçüíª <span id="userName">Loading...</span></div>
        <div style="margin-top: 5px;">
            <button class="auth-btn" onclick="logout()" style="padding: 4px 8px; font-size: 0.8em;">Logout</button>
        </div>
    </div>

    <div class="game-header">
        <h1 class="game-title">ü¶ñ‚Üíüì° XANO DASH</h1>
        <p class="game-subtitle">Geometry Edition ‚ö°</p>
        <p class="tagline">"The only time your backend fails‚Ä¶ is when you're not using Xano."</p>
    </div>

    <canvas id="gameCanvas" width="1000" height="400"></canvas>

    <div class="controls">
        <p>üéÆ <strong>SPACE/CLICK</strong> to jump | <strong>DOWN</strong> to duck | <strong>P</strong> to pause | <strong>R</strong> to restart</p>
        <p>‚ö° Watch for spikes, saws, and portals! | Jump pads boost you higher!</p>
        <p>Survive the backend nightmare! Click anywhere to start!</p>
    </div>

    <div class="game-over" id="gameOver">
        <h2 style="color: #ff6b6b;">BACKEND CRASHED! üí•</h2>
        <p id="finalScore">Score: 0</p>
        <div id="scorePrompt" style="display: none; margin: 15px 0; padding: 15px; background: rgba(0, 245, 255, 0.1); border-radius: 8px; border: 1px solid #00f5ff;">
            <p style="color: #00f5ff; margin: 0 0 10px 0;">üèÜ Want to save this score to the leaderboard?</p>
            <p style="color: #4ecdc4; font-size: 0.9em; margin: 0 0 15px 0;">Sign up now to compete with other backend survivors!</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="showSignupModal()" style="padding: 8px 16px; background: #00f5ff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Sign Up</button>
                <button onclick="showLoginModal()" style="padding: 8px 16px; background: transparent; color: #4ecdc4; border: 1px solid #4ecdc4; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Login</button>
            </div>
        </div>
        <p style="color: #4ecdc4;">Maybe use Xano next time? üòâ</p>
        <button onclick="restartGame()" style="padding: 10px 20px; font-size: 1.1em; background: #00f5ff; border: none; border-radius: 5px; cursor: pointer; box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);">Try Again</button>
    </div>

    <div class="backend-joke">
        <p><strong>Backend Status:</strong> <span style="color: #ff6b6b;">‚ùå Not Found</span></p>
        <p>"This is what happens when your app goes offline‚Ä¶ unless you're on Xano."</p>
        <p style="font-size: 0.7em; margin-top: 10px; color: #666;">
            Geometry Dash style meets backend nightmares ‚Äî powered by Xano's rock-solid infrastructure.
        </p>
    </div>

    <!-- Modals (same as before) -->
    <div class="modal" id="loginModal">
        <div class="modal-content">
            <h2>üîê Login to Xano Dash</h2>
            <form id="loginForm">
                <div class="form-group">
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password:</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <div id="loginError" class="error-message"></div>
                <div class="modal-buttons">
                    <button type="submit" class="modal-btn primary">Login</button>
                    <button type="button" class="modal-btn secondary" onclick="closeModal('loginModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="signupModal">
        <div class="modal-content">
            <h2>üöÄ Join the Backend Warriors</h2>
            <form id="signupForm">
                <div class="form-group">
                    <label for="signupName">Username:</label>
                    <input type="text" id="signupName" required>
                </div>
                <div class="form-group">
                    <label for="signupEmail">Email:</label>
                    <input type="email" id="signupEmail" required>
                </div>
                <div class="form-group">
                    <label for="signupPassword">Password:</label>
                    <input type="password" id="signupPassword" required>
                </div>
                <div id="signupError" class="error-message"></div>
                <div class="modal-buttons">
                    <button type="submit" class="modal-btn primary">Sign Up</button>
                    <button type="button" class="modal-btn secondary" onclick="closeModal('signupModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="modal" id="leaderboardModal">
        <div class="modal-content">
            <h2>üèÜ Backend Nightmare Survivors</h2>
            <div id="leaderboardContent">
                <p style="text-align: center; color: #4ecdc4;">Loading leaderboard...</p>
            </div>
            <div class="modal-buttons">
                <button type="button" class="modal-btn secondary" onclick="closeModal('leaderboardModal')">Close</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Xano API Configuration
        const XANO_AUTH_API = 'https://xxmf-qrth-inat.n7d.xano.io/api:S2PDGkeW';
        const XANO_LEADERBOARD_API = 'https://xxmf-qrth-inat.n7d.xano.io/api:S2PDGkeW';
        
        // Authentication state
        let currentUser = null;
        let authToken = localStorage.getItem('xanoAuthToken');
        let currentGameId = null;
        let lastScore = 0;

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        let score = 0;
        let highScore = localStorage.getItem('xanoHighScore') || 0;
        let gameSpeed = 3.5; // Faster like Geometry Dash!
        let baseGameSpeed = 3.5;
        let isRainbowMode = false;
        let konamiCode = [];
        const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
        let comboCount = 0;
        let comboMultiplier = 1;
        let lastObstacleTime = 0;
        let lastSpeedIncrease = 0;
        let gameLoopId = null;
        let nearMissCount = 0;
        let screenShake = 0;
        let backgroundOffset = 0;
        let colorPhase = 0; // For dynamic color changes

        // Player
        const player = {
            x: 120,
            y: canvas.height - 80,
            width: 40,
            height: 40,
            jumpHeight: 0,
            jumpSpeed: 0,
            grounded: true,
            ducking: false,
            duckHeight: 20,
            doubleJump: false,
            invincible: false,
            invincibleStartTime: 0,
            invincibleDuration: 0,
            trail: [],
            rotation: 0 // For rotating player like Geometry Dash
        };

        // Game objects
        let obstacles = [];
        let powerUps = [];
        let particles = [];
        let jumpPads = [];
        let obstacleSpawnTimer = 0;
        let powerUpSpawnTimer = 0;
        let jumpPadSpawnTimer = 0;

        // GEOMETRY DASH STYLE OBSTACLES
        const obstacleTypes = [
            // Spikes (triangles)
            { 
                type: 'spike-ground', 
                width: 30, 
                height: 30, 
                color: '#ff6b6b',
                glow: '#ff0000',
                emoji: '‚õî',
                text: '502',
                shape: 'triangle',
                humor: "Sharp edges ahead!"
            },
            { 
                type: 'spike-ground', 
                width: 25, 
                height: 25, 
                color: '#ff9f43',
                glow: '#ff7f00',
                emoji: 'üó°Ô∏è',
                text: 'SQL',
                shape: 'triangle',
                humor: "Bobby Tables strikes!"
            },
            { 
                type: 'spike-ground', 
                width: 35, 
                height: 35, 
                color: '#fd79a8',
                glow: '#ff0080',
                emoji: 'üö´',
                text: 'CORS',
                shape: 'triangle',
                humor: "Access denied!"
            },
            
            // Rotating saws
            { 
                type: 'saw-mid', 
                width: 40, 
                height: 40, 
                color: '#e17055',
                glow: '#ff4500',
                emoji: '‚ö°',
                text: 'CACHE',
                shape: 'saw',
                rotation: 0,
                rotationSpeed: 0.1,
                humor: "Spinning doom!"
            },
            { 
                type: 'saw-high', 
                width: 45, 
                height: 45, 
                color: '#6c5ce7',
                glow: '#4b0082',
                emoji: 'üå™Ô∏è',
                text: 'DDOS',
                shape: 'saw',
                rotation: 0,
                rotationSpeed: 0.15,
                humor: "Traffic tsunami!"
            },
            
            // Moving obstacles
            { 
                type: 'moving-vertical', 
                width: 35, 
                height: 35, 
                color: '#00b894',
                glow: '#00ff80',
                emoji: 'üíæ',
                text: 'LOCK',
                shape: 'square',
                moveSpeed: 2,
                moveRange: 80,
                moveOffset: 0,
                humor: "Up and down madness!"
            },
            
            // Platforms
            { 
                type: 'platform', 
                width: 80, 
                height: 20, 
                color: '#636e72',
                glow: '#ffffff',
                emoji: 'üîß',
                text: 'MAINT',
                shape: 'platform',
                humor: "Jump through this!"
            },
            
            // Portal obstacles
            { 
                type: 'portal', 
                width: 30, 
                height: 50, 
                color: '#a29bfe',
                glow: '#8b00ff',
                emoji: 'üï≥Ô∏è',
                text: 'NULL',
                shape: 'portal',
                pulse: 0,
                humor: "Into the void!"
            },
            
            // Tall obstacles
            { 
                type: 'wall', 
                width: 25, 
                height: 60, 
                color: '#26de81',
                glow: '#00ff00',
                emoji: 'üêå',
                text: 'SLOW',
                shape: 'rectangle',
                humor: "The tall wall of lag!"
            }
        ];

        // Power-ups
        const powerUpTypes = [
            { emoji: 'üß†', text: 'Invincible', color: '#00cec9', effect: 'invincible', glow: '#00ffff' },
            { emoji: '‚öôÔ∏è', text: 'Double Jump', color: '#6c5ce7', effect: 'doubleJump', glow: '#8b00ff' },
            { emoji: 'üõ°Ô∏è', text: 'Slow-Mo', color: '#a29bfe', effect: 'slowDown', glow: '#ff00ff' },
        ];

        function drawPlayer() {
            ctx.save();
            
            // Trail effect
            if (gameRunning && !gamePaused) {
                player.trail.push({ x: player.x, y: player.y - player.jumpHeight, alpha: 0.5 });
                if (player.trail.length > 10) player.trail.shift();
            }
            
            // Draw trail
            player.trail.forEach((t, i) => {
                ctx.globalAlpha = t.alpha * (i / player.trail.length);
                const gradient = ctx.createRadialGradient(
                    t.x + player.width/2, t.y + player.height/2, 0,
                    t.x + player.width/2, t.y + player.height/2, player.width
                );
                gradient.addColorStop(0, '#00f5ff');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fillRect(t.x, t.y, player.width, player.height);
            });
            
            ctx.globalAlpha = 1;
            
            const currentHeight = player.ducking && player.grounded ? player.duckHeight : player.height;
            const currentY = player.y - player.jumpHeight + (player.ducking && player.grounded ? player.height - player.duckHeight : 0);

            // Rotate player when jumping (Geometry Dash style)
            ctx.translate(player.x + player.width/2, currentY + currentHeight/2);
            if (!player.grounded) {
                player.rotation += 0.15;
            } else {
                player.rotation = 0;
            }
            ctx.rotate(player.rotation);
            
            // Glow effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00f5ff';
            
            const gradient = ctx.createLinearGradient(-player.width/2, -currentHeight/2, player.width/2, currentHeight/2);
            gradient.addColorStop(0, '#00f5ff');
            gradient.addColorStop(0.5, '#0091ff');
            gradient.addColorStop(1, '#005fff');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(-player.width/2, -currentHeight/2, player.width, currentHeight);
            
            // Border
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-player.width/2, -currentHeight/2, player.width, currentHeight);
            
            ctx.shadowBlur = 0;
            
            // XANO text
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('XANO', 0, 4);

            if (isRainbowMode) {
                for (let i = 0; i < 15; i++) {
                    ctx.fillStyle = `hsl(${(Date.now() * 0.2 + i * 24) % 360}, 100%, 50%)`;
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(-player.width/2 - i * 3, -currentHeight/2, player.width, currentHeight);
                }
            }

            ctx.restore();
        }

        function drawObstacle(obstacle) {
            ctx.save();
            
            // Glow effect
            ctx.shadowBlur = 15;
            ctx.shadowColor = obstacle.glow || obstacle.color;
            
            switch (obstacle.shape) {
                case 'triangle': // Spikes
                    ctx.fillStyle = obstacle.color;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
                    ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Border
                    ctx.strokeStyle = obstacle.glow;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                    
                case 'saw': // Rotating saw
                    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                    ctx.rotate(obstacle.rotation);
                    
                    // Draw saw blades
                    ctx.fillStyle = obstacle.color;
                    const blades = 8;
                    for (let i = 0; i < blades; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(obstacle.width/2 * Math.cos(i * Math.PI * 2 / blades), 
                                   obstacle.width/2 * Math.sin(i * Math.PI * 2 / blades));
                        ctx.lineTo(obstacle.width/2 * Math.cos((i + 0.5) * Math.PI * 2 / blades), 
                                   obstacle.width/2 * Math.sin((i + 0.5) * Math.PI * 2 / blades));
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Center circle
                    ctx.fillStyle = obstacle.glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, obstacle.width/4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.rotate(-obstacle.rotation);
                    ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                    break;
                    
                case 'portal': // Pulsing portal
                    obstacle.pulse = (obstacle.pulse || 0) + 0.05;
                    const pulseSize = Math.sin(obstacle.pulse) * 5 + obstacle.width;
                    
                    const gradient = ctx.createRadialGradient(
                        obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 0,
                        obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, pulseSize/2
                    );
                    gradient.addColorStop(0, obstacle.color);
                    gradient.addColorStop(0.7, obstacle.glow);
                    gradient.addColorStop(1, 'transparent');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 
                               pulseSize/2, obstacle.height/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'platform':
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    // Top glow line
                    ctx.strokeStyle = obstacle.glow;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(obstacle.x, obstacle.y);
                    ctx.lineTo(obstacle.x + obstacle.width, obstacle.y);
                    ctx.stroke();
                    break;
                    
                default: // Rectangle/square
                    ctx.fillStyle = obstacle.color;
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    ctx.strokeStyle = obstacle.glow;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    break;
            }
            
            ctx.shadowBlur = 0;
            
            // Emoji and text
            ctx.font = '18px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(obstacle.emoji, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2 + 6);
            
            ctx.restore();
        }

        function drawJumpPad(pad) {
            ctx.save();
            
            // Animate bounce
            pad.bouncePhase = (pad.bouncePhase || 0) + 0.1;
            const bounceY = Math.sin(pad.bouncePhase) * 3;
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffd700';
            
            // Draw spring/pad
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(pad.x, pad.y + bounceY, pad.width, pad.height);
            
            // Arrow indicator
            ctx.fillStyle = '#000';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('‚Üë', pad.x + pad.width/2, pad.y + bounceY + 20);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawPowerUp(powerUp) {
            const float = Math.sin(Date.now() * 0.005 + powerUp.x * 0.01) * 8;
            
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = powerUp.glow;
            
            const gradient = ctx.createRadialGradient(
                powerUp.x + 20, powerUp.y + float + 20, 5,
                powerUp.x + 20, powerUp.y + float + 20, 25
            );
            gradient.addColorStop(0, powerUp.color);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(powerUp.x + 20, powerUp.y + float + 20, 25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(powerUp.emoji, powerUp.x + 20, powerUp.y + float + 28);
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function drawParticle(particle) {
            ctx.save();
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = particle.life;
            ctx.shadowBlur = 10;
            ctx.shadowColor = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function createObstacleWave() {
            const difficultyLevel = Math.floor(score / 3000);
            const rand = Math.random();
            
            // Single obstacle
            if (rand < 0.6) {
                const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                createObstacle(type);
            }
            // Double obstacle
            else if (rand < 0.85) {
                const type1 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const type2 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                createObstacle(type1, 0);
                createObstacle(type2, 150);
            }
            // Triple obstacle (hard!)
            else {
                const type1 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const type2 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                const type3 = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                createObstacle(type1, 0);
                createObstacle(type2, 120);
                createObstacle(type3, 240);
            }
        }

        function createObstacle(type, xOffset = 0) {
            let y;
            switch (type.type) {
                case 'spike-ground':
                    y = canvas.height - type.height - 30;
                    break;
                case 'saw-mid':
                    y = canvas.height - 120;
                    break;
                case 'saw-high':
                    y = canvas.height - 180;
                    break;
                case 'moving-vertical':
                    y = canvas.height - 100;
                    break;
                case 'platform':
                    y = canvas.height - 120;
                    break;
                case 'portal':
                    y = canvas.height - type.height - 30;
                    break;
                case 'wall':
                    y = canvas.height - type.height - 30;
                    break;
            }

            obstacles.push({
                x: canvas.width + xOffset,
                y: y,
                baseY: y,
                width: type.width,
                height: type.height,
                emoji: type.emoji,
                text: type.text,
                color: type.color,
                glow: type.glow,
                shape: type.shape,
                type: type.type,
                humor: type.humor,
                rotation: type.rotation || 0,
                rotationSpeed: type.rotationSpeed || 0,
                moveSpeed: type.moveSpeed || 0,
                moveRange: type.moveRange || 0,
                moveOffset: type.moveOffset || 0,
                pulse: type.pulse || 0,
                passed: false
            });
        }

        function createJumpPad() {
            jumpPads.push({
                x: canvas.width,
                y: canvas.height - 50,
                width: 40,
                height: 20,
                bouncePhase: 0
            });
        }

        function createPowerUp() {
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            const height = 100 + Math.random() * 100;
            
            powerUps.push({
                x: canvas.width,
                y: canvas.height - height,
                emoji: type.emoji,
                text: type.text,
                color: type.color,
                glow: type.glow,
                effect: type.effect
            });
        }

        function createParticles(x, y, color, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8 - 2,
                    size: Math.random() * 4 + 2,
                    life: 1,
                    color: color
                });
            }
        }

        function updatePlayer() {
            const now = Date.now();
            
            if (!player.grounded) {
                player.jumpSpeed += 0.5;
                player.jumpHeight -= player.jumpSpeed;
                
                if (player.jumpHeight <= 0) {
                    player.jumpHeight = 0;
                    player.jumpSpeed = 0;
                    player.grounded = true;
                    player.rotation = 0;
                    createParticles(player.x + player.width/2, player.y, '#00f5ff', 8);
                }
            }

            if (player.invincible) {
                const elapsed = now - player.invincibleStartTime;
                if (elapsed >= player.invincibleDuration) {
                    player.invincible = false;
                }
            }
        }

        function updateObstacles() {
            obstacles = obstacles.filter(obstacle => {
                obstacle.x -= gameSpeed;
                
                // Update rotation for saws
                if (obstacle.rotationSpeed) {
                    obstacle.rotation += obstacle.rotationSpeed;
                }
                
                // Update vertical movement
                if (obstacle.moveSpeed) {
                    obstacle.moveOffset += obstacle.moveSpeed;
                    obstacle.y = obstacle.baseY + Math.sin(obstacle.moveOffset * 0.05) * obstacle.moveRange;
                }
                
                return obstacle.x + obstacle.width > 0;
            });

            obstacleSpawnTimer += 1;
            let spawnInterval = Math.max(50, 100 - Math.floor(score / 3000) * 8);
            
            if (obstacleSpawnTimer >= spawnInterval) {
                createObstacleWave();
                obstacleSpawnTimer = 0;
            }
        }

        function updateJumpPads() {
            jumpPads = jumpPads.filter(pad => {
                pad.x -= gameSpeed;
                return pad.x + pad.width > 0;
            });

            jumpPadSpawnTimer += 1;
            if (jumpPadSpawnTimer >= 400 && Math.random() < 0.3) {
                createJumpPad();
                jumpPadSpawnTimer = 0;
            }
        }

        function updatePowerUps() {
            powerUps = powerUps.filter(powerUp => {
                powerUp.x -= gameSpeed;
                return powerUp.x + 40 > 0;
            });

            powerUpSpawnTimer += 1;
            if (powerUpSpawnTimer >= 350 && Math.random() < 0.2) {
                createPowerUp();
                powerUpSpawnTimer = 0;
            }
        }

        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.15;
                particle.life -= 0.02;
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            const currentHeight = player.ducking && player.grounded ? player.duckHeight : player.height;
            const currentY = player.y - player.jumpHeight + (player.ducking && player.grounded ? player.height - player.duckHeight : 0);

            // Check obstacles
            obstacles.forEach((obstacle) => {
                const hitboxMargin = 5;
                
                let collided = false;
                
                if (obstacle.shape === 'triangle') {
                    // Triangle collision (more forgiving)
                    const centerX = obstacle.x + obstacle.width/2;
                    const topY = obstacle.y;
                    const bottomY = obstacle.y + obstacle.height;
                    
                    if (player.x + player.width > obstacle.x + hitboxMargin &&
                        player.x < obstacle.x + obstacle.width - hitboxMargin &&
                        currentY + currentHeight > topY + hitboxMargin) {
                        collided = true;
                    }
                } else {
                    // Rectangle collision
                    if (player.x + hitboxMargin < obstacle.x + obstacle.width - hitboxMargin &&
                        player.x + player.width - hitboxMargin > obstacle.x + hitboxMargin &&
                        currentY + hitboxMargin < obstacle.y + obstacle.height - hitboxMargin &&
                        currentY + currentHeight - hitboxMargin > obstacle.y + hitboxMargin) {
                        collided = true;
                    }
                }
                
                if (collided && !player.invincible) {
                    createParticles(player.x + player.width/2, currentY + currentHeight/2, '#ff0000', 30);
                    gameOver(obstacle.humor);
                }
                
                if (obstacle.x + obstacle.width < player.x && !obstacle.passed) {
                    obstacle.passed = true;
                    comboCount++;
                    comboMultiplier = 1 + (comboCount * 0.15);
                    lastObstacleTime = Date.now();
                    createParticles(obstacle.x, obstacle.y, obstacle.color, 10);
                }
            });

            // Check jump pads
            jumpPads.forEach((pad) => {
                if (player.x < pad.x + pad.width &&
                    player.x + player.width > pad.x &&
                    currentY + currentHeight > pad.y &&
                    player.grounded) {
                    
                    player.jumpSpeed = -18; // Super jump!
                    player.grounded = false;
                    createParticles(pad.x + pad.width/2, pad.y, '#ffd700', 25);
                    screenShake = 8;
                }
            });

            // Check power-ups
            powerUps = powerUps.filter(powerUp => {
                if (player.x < powerUp.x + 40 &&
                    player.x + player.width > powerUp.x &&
                    currentY < powerUp.y + 40 &&
                    currentY + currentHeight > powerUp.y) {
                    
                    activatePowerUp(powerUp.effect);
                    createParticles(powerUp.x + 20, powerUp.y + 20, powerUp.color, 25);
                    return false;
                }
                return true;
            });
        }

        function activatePowerUp(effect) {
            const now = Date.now();
            
            switch (effect) {
                case 'invincible':
                    player.invincible = true;
                    player.invincibleStartTime = now;
                    player.invincibleDuration = 5000;
                    break;
                case 'doubleJump':
                    player.doubleJump = true;
                    break;
                case 'slowDown':
                    gameSpeed = Math.max(2.0, gameSpeed - 1.5);
                    setTimeout(() => {
                        gameSpeed = baseGameSpeed + Math.floor(score / 1000) * 0.2;
                    }, 3000);
                    break;
            }
        }

        function jump() {
            if (player.grounded) {
                player.jumpSpeed = -14;
                player.grounded = false;
                createParticles(player.x + player.width/2, player.y, '#00f5ff', 12);
            } else if (player.doubleJump) {
                player.jumpSpeed = -12;
                player.doubleJump = false;
                createParticles(player.x + player.width/2, player.y - player.jumpHeight, '#6c5ce7', 15);
            }
        }

        function duck(isDucking) {
            if (player.grounded) {
                player.ducking = isDucking;
            }
        }

        function gameOver(deathMessage = "Your backend just crashed!") {
            gameRunning = false;
            gamePaused = false;
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            canvas.classList.add('death-animation');
            setTimeout(() => canvas.classList.remove('death-animation'), 500);
            
            const isNewHighScore = score > highScore;
            if (isNewHighScore) {
                highScore = score;
                localStorage.setItem('xanoHighScore', highScore);
            }
            
            const finalScoreElement = document.getElementById('finalScore');
            
            if (isNewHighScore && score > 0) {
                finalScoreElement.classList.add('new-high-score');
                finalScoreElement.textContent = `üéâ NEW HIGH SCORE: ${score.toLocaleString()}! üéâ`;
            } else {
                finalScoreElement.classList.remove('new-high-score');
                finalScoreElement.textContent = `Score: ${score.toLocaleString()}`;
            }
            
            const gameOverDiv = document.getElementById('gameOver');
            const existingHumor = gameOverDiv.querySelector('.death-humor');
            if (existingHumor) {
                existingHumor.textContent = deathMessage;
            } else {
                const humorP = document.createElement('p');
                humorP.className = 'death-humor';
                humorP.style.cssText = 'color: #ff6b6b; font-style: italic; margin: 10px 0; font-size: 0.9em;';
                humorP.textContent = deathMessage;
                gameOverDiv.insertBefore(humorP, document.getElementById('scorePrompt'));
            }
            gameOverDiv.style.display = 'block';
            
            lastScore = score;
            
            const scorePrompt = document.getElementById('scorePrompt');
            if (!authToken && score > 500) {
                scorePrompt.style.display = 'block';
            } else {
                scorePrompt.style.display = 'none';
            }
            
            if (authToken && currentGameId) {
                submitScore(score, currentGameId);
                setTimeout(() => showLeaderboard(), 1000);
            }
        }

        function restartGame() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameSpeed = baseGameSpeed;
            gameRunning = true;
            gamePaused = false;
            score = 0;
            obstacles = [];
            powerUps = [];
            particles = [];
            jumpPads = [];
            comboCount = 0;
            comboMultiplier = 1;
            nearMissCount = 0;
            screenShake = 0;
            obstacleSpawnTimer = 0;
            powerUpSpawnTimer = 0;
            jumpPadSpawnTimer = 0;
            backgroundOffset = 0;
            colorPhase = 0;
            
            player.x = 120;
            player.y = canvas.height - 80;
            player.jumpHeight = 0;
            player.jumpSpeed = 0;
            player.grounded = true;
            player.ducking = false;
            player.invincible = false;
            player.doubleJump = false;
            player.trail = [];
            player.rotation = 0;
            
            isRainbowMode = false;
            document.getElementById('gameOver').style.display = 'none';
            
            if (authToken) createGameSession();
            if (!gameLoopId) gameLoop();
        }
        
        function togglePause() {
            if (gameRunning) {
                gamePaused = !gamePaused;
            }
        }

        function drawBackground() {
            ctx.save();
            
            // Screen shake
            if (screenShake > 0) {
                ctx.translate(
                    Math.random() * screenShake - screenShake / 2,
                    Math.random() * screenShake - screenShake / 2
                );
                screenShake *= 0.85;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            // Dynamic background
            colorPhase += 0.001;
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, `hsl(${200 + Math.sin(colorPhase) * 20}, 50%, 15%)`);
            gradient.addColorStop(1, `hsl(${220 + Math.sin(colorPhase) * 20}, 50%, 12%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animated grid
            backgroundOffset += gameSpeed * 0.5;
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
            ctx.lineWidth = 1;
            
            for (let x = -(backgroundOffset % 50); x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Ground
            const groundGradient = ctx.createLinearGradient(0, canvas.height - 30, 0, canvas.height);
            groundGradient.addColorStop(0, '#222');
            groundGradient.addColorStop(1, '#111');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);
            
            // Ground glow line
            ctx.strokeStyle = '#00f5ff';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f5ff';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height - 30);
            ctx.lineTo(canvas.width, canvas.height - 30);
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }

        function drawUI() {
            ctx.font = 'bold 28px Courier New';
            ctx.fillStyle = '#00f5ff';
            ctx.textAlign = 'left';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00f5ff';
            ctx.fillText(`${score.toLocaleString()}`, 20, 40);
            ctx.shadowBlur = 0;
            
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`Best: ${parseInt(highScore).toLocaleString()}`, 20, 65);

            if (comboCount > 0) {
                ctx.font = 'bold 22px Courier New';
                ctx.fillStyle = '#ffd700';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffd700';
                ctx.fillText(`üî• COMBO x${comboCount}`, 20, 100);
                ctx.shadowBlur = 0;
            }

            let yOffset = 130;
            const now = Date.now();
            
            if (player.invincible) {
                const elapsed = now - player.invincibleStartTime;
                const timeLeft = Math.max(0, Math.ceil((player.invincibleDuration - elapsed) / 1000));
                ctx.font = '18px Courier New';
                ctx.fillStyle = '#00cec9';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00cec9';
                ctx.fillText(`üß† INVINCIBLE (${timeLeft}s)`, 20, yOffset);
                ctx.shadowBlur = 0;
                yOffset += 25;
            }
            
            if (player.doubleJump) {
                ctx.font = '18px Courier New';
                ctx.fillStyle = '#6c5ce7';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#6c5ce7';
                ctx.fillText('‚öôÔ∏è DOUBLE JUMP', 20, yOffset);
                ctx.shadowBlur = 0;
            }
            
            if (gamePaused) {
                ctx.font = 'bold 56px Courier New';
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00f5ff';
                ctx.fillText('‚è∏Ô∏è PAUSED', canvas.width/2, canvas.height/2);
                ctx.shadowBlur = 0;
            }

            if (isRainbowMode) {
                ctx.font = 'bold 24px Courier New';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff00ff';
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                for (let i = 0; i < 7; i++) {
                    gradient.addColorStop(i / 6, `hsl(${i * 60}, 100%, 50%)`);
                }
                ctx.fillStyle = gradient;
                ctx.fillText('üåà XANO RAINBOW MODE! üåà', canvas.width/2, 50);
                ctx.shadowBlur = 0;
            }
        }

        function gameLoop() {
            if (!gameRunning) {
                gameLoopId = null;
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            if (!gamePaused) {
                updatePlayer();
                updateObstacles();
                updateJumpPads();
                updatePowerUps();
                updateParticles();
                checkCollisions();

                score += Math.floor(2 * comboMultiplier);
                
                if (comboCount > 0 && Date.now() - lastObstacleTime > 3000) {
                    comboCount = 0;
                    comboMultiplier = 1;
                }
                
                if (score > 0 && score % 1000 === 0 && score !== lastSpeedIncrease) {
                    gameSpeed = baseGameSpeed + Math.floor(score / 1000) * 0.2;
                    lastSpeedIncrease = score;
                }
            }

            particles.forEach(drawParticle);
            obstacles.forEach(drawObstacle);
            jumpPads.forEach(drawJumpPad);
            powerUps.forEach(drawPowerUp);
            drawPlayer();
            drawUI();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            const target = e.target;
            const tagName = target && target.tagName ? target.tagName.toUpperCase() : '';
            if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') return;
            
            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                restartGame();
                return;
            }
            
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                togglePause();
                return;
            }
            
            if ((e.key === 'ArrowDown' || e.key === 'Down') && gameRunning && !gamePaused) {
                e.preventDefault();
                duck(true);
            }
            
            if ((e.code === 'Space' || e.key === ' ') && gameRunning && !gamePaused) {
                e.preventDefault();
                jump();
            }

            konamiCode.push(e.keyCode);
            if (konamiCode.length > konamiSequence.length) konamiCode.shift();
            
            if (konamiCode.every((code, i) => code === konamiSequence[i])) {
                isRainbowMode = !isRainbowMode;
                konamiCode = [];
                if (isRainbowMode) {
                    player.invincible = true;
                    player.invincibleStartTime = Date.now();
                    player.invincibleDuration = 10000;
                }
            }

            if ((e.code === 'Space' || e.key === ' ') && !gameRunning) {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowDown' || e.key === 'Down') {
                duck(false);
            }
        });

        canvas.addEventListener('click', () => {
            if (gameRunning && !gamePaused) {
                jump();
            } else {
                restartGame();
            }
        });

        // Auth functions (same as before)
        async function login(email, password) {
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                const data = await response.json();
                if (response.ok) {
                    authToken = data.authToken;
                    localStorage.setItem('xanoAuthToken', authToken);
                    await getCurrentUser();
                    updateAuthUI();
                    return { success: true };
                }
                return { success: false, error: data.message || 'Login failed' };
            } catch (error) {
                return { success: false, error: 'Network error' };
            }
        }

        async function signup(name, email, password) {
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/signup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, email, password })
                });
                const data = await response.json();
                if (response.ok) {
                    authToken = data.authToken;
                    localStorage.setItem('xanoAuthToken', authToken);
                    await getCurrentUser();
                    updateAuthUI();
                    return { success: true };
                }
                return { success: false, error: data.message || 'Signup failed' };
            } catch (error) {
                return { success: false, error: 'Network error' };
            }
        }

        async function getCurrentUser() {
            if (!authToken) return;
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/me`, {
                    headers: { 'Authorization': `Bearer ${authToken}` }
                });
                if (response.ok) {
                    currentUser = await response.json();
                } else {
                    logout();
                }
            } catch (error) {
                console.error('Error getting user:', error);
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            currentGameId = null;
            localStorage.removeItem('xanoAuthToken');
            updateAuthUI();
        }

        function updateAuthUI() {
            const authSection = document.getElementById('authSection');
            const userInfo = document.getElementById('userInfo');
            
            if (currentUser) {
                authSection.style.display = 'none';
                userInfo.style.display = 'block';
                document.getElementById('userName').textContent = currentUser.name;
                
                if (lastScore > 0 && !gameRunning) {
                    submitScoreAfterAuth(lastScore);
                    lastScore = 0;
                }
            } else {
                authSection.style.display = 'flex';
                userInfo.style.display = 'none';
            }
        }

        async function createGameSession() {
            if (!authToken) return;
            try {
                const response = await fetch(`${XANO_LEADERBOARD_API}/game`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (response.ok) {
                    const data = await response.json();
                    currentGameId = data.id;
                }
            } catch (error) {
                console.error('Error creating game session:', error);
            }
        }

        async function submitScore(playerScore, gameId) {
            if (!authToken || !gameId) return;
            try {
                await fetch(`${XANO_LEADERBOARD_API}/score`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({ score: playerScore, game_id: gameId })
                });
            } catch (error) {
                console.error('Error submitting score:', error);
            }
        }

        async function submitScoreAfterAuth(playerScore) {
            try {
                const gameResponse = await fetch(`${XANO_LEADERBOARD_API}/game`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (gameResponse.ok) {
                    const gameData = await gameResponse.json();
                    await submitScore(playerScore, gameData.id);
                    alert(`üéâ Score ${playerScore.toLocaleString()} saved!`);
                    document.getElementById('scorePrompt').style.display = 'none';
                }
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function getLeaderboard() {
            try {
                const response = await fetch(`${XANO_LEADERBOARD_API}/leaderboards`);
                if (response.ok) {
                    const data = await response.json();
                    return data.items || [];
                }
                return [];
            } catch (error) {
                return [];
            }
        }

        function showLoginModal() {
            document.getElementById('loginModal').style.display = 'flex';
        }

        function showSignupModal() {
            document.getElementById('signupModal').style.display = 'flex';
        }

        async function showLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            const content = document.getElementById('leaderboardContent');
            
            modal.style.display = 'flex';
            content.innerHTML = '<div class="loading-text"><div class="loading-spinner"></div>Loading...</div>';
            
            const leaderboard = await getLeaderboard();
            
            if (leaderboard.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #ff6b6b;">No scores yet!</p>';
                return;
            }
            
            let html = '<table class="leaderboard-table"><thead><tr><th>Rank</th><th>Player</th><th>Score</th></tr></thead><tbody>';
            
            leaderboard.forEach((entry, index) => {
                const rank = index + 1;
                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                html += `<tr><td>${rankEmoji}</td><td>${entry.user ? entry.user.name : 'Anonymous'}</td><td>${entry.score.toLocaleString()}</td></tr>`;
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const result = await login(
                document.getElementById('loginEmail').value,
                document.getElementById('loginPassword').value
            );
            if (result.success) {
                closeModal('loginModal');
                document.getElementById('loginForm').reset();
            } else {
                document.getElementById('loginError').textContent = result.error;
            }
        });

        document.getElementById('signupForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const result = await signup(
                document.getElementById('signupName').value,
                document.getElementById('signupEmail').value,
                document.getElementById('signupPassword').value
            );
            if (result.success) {
                closeModal('signupModal');
                document.getElementById('signupForm').reset();
            } else {
                document.getElementById('signupError').textContent = result.error;
            }
        });

        // Initialize
        if (authToken) {
            getCurrentUser().then(updateAuthUI);
        }

        drawBackground();
        drawUI();
        ctx.font = 'bold 48px Courier New';
        ctx.fillStyle = '#00f5ff';
        ctx.textAlign = 'center';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f5ff';
        ctx.fillText('CLICK TO START', canvas.width/2, canvas.height/2);
        ctx.shadowBlur = 0;
        ctx.font = '20px Courier New';
        ctx.fillStyle = '#4ecdc4';
        ctx.fillText('Space to jump, Down to duck', canvas.width/2, canvas.height/2 + 50);
    </script>
</body>
</html>

