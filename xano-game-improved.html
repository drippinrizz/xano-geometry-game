<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xano Dash - Improved Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #fff;
        }
        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .game-title {
            font-size: 2.5em;
            color: #00f5ff;
            text-shadow: 0 0 10px #00f5ff;
            margin: 0;
        }
        .game-subtitle {
            font-size: 1.2em;
            color: #ff6b6b;
            margin: 5px 0;
        }
        .tagline {
            font-size: 0.9em;
            color: #4ecdc4;
            font-style: italic;
        }
        canvas {
            border: 2px solid #00f5ff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
            background: #0a0a0a;
        }
        .controls {
            margin-top: 15px;
            text-align: center;
            font-size: 0.9em;
            color: #aaa;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #ff6b6b;
            text-align: center;
            display: none;
        }
        .backend-joke {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            font-size: 0.8em;
            max-width: 600px;
            text-align: center;
        }
        .auth-section {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .auth-btn, .leaderboard-btn {
            padding: 8px 16px;
            background: rgba(0, 245, 255, 0.2);
            border: 1px solid #00f5ff;
            border-radius: 5px;
            color: #00f5ff;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        .auth-btn:hover, .leaderboard-btn:hover {
            background: rgba(0, 245, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00f5ff;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
            min-width: 400px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal h2 {
            color: #00f5ff;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00f5ff;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            color: #4ecdc4;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .form-group input {
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00f5ff;
            border-radius: 5px;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .form-group input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 1em;
            transition: all 0.3s ease;
        }
        .modal-btn.primary {
            background: #00f5ff;
            color: #000;
        }
        .modal-btn.primary:hover {
            background: #4ecdc4;
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
        }
        .modal-btn.secondary {
            background: transparent;
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }
        .modal-btn.secondary:hover {
            background: rgba(255, 107, 107, 0.2);
        }
        .user-info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #4ecdc4;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #4ecdc4;
        }
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .leaderboard-table th,
        .leaderboard-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 245, 255, 0.2);
        }
        .leaderboard-table th {
            color: #00f5ff;
            font-weight: bold;
        }
        .leaderboard-table td {
            color: #fff;
        }
        .leaderboard-table tr:hover {
            background: rgba(0, 245, 255, 0.1);
        }
        .error-message {
            color: #ff6b6b;
            font-size: 0.8em;
            margin-top: 5px;
            text-align: center;
        }
        .success-message {
            color: #4ecdc4;
            font-size: 0.8em;
            margin-top: 5px;
            text-align: center;
        }
        .rainbow {
            background: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            background-size: 400% 400%;
            animation: rainbow 2s linear infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .loading-spinner {
            border: 2px solid rgba(0, 245, 255, 0.2);
            border-radius: 50%;
            border-top: 2px solid #00f5ff;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            color: #4ecdc4;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
        }
        .death-animation {
            animation: deathShake 0.5s ease-in-out;
        }
        @keyframes deathShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .new-high-score {
            color: #ffd700 !important;
            text-shadow: 0 0 20px #ffd700;
            animation: pulseGold 1s ease-in-out infinite;
        }
        @keyframes pulseGold {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }
    </style>
</head>
<body>
    <!-- Authentication Section -->
    <div class="auth-section" id="authSection">
        <button class="auth-btn" onclick="showLoginModal()">Login</button>
        <button class="auth-btn" onclick="showSignupModal()">Sign Up</button>
    </div>

    <!-- Leaderboard Button -->
    <div class="auth-section" id="leaderboardBtnContainer" style="top: 70px; right: 20px; position: fixed; z-index: 1000; display: flex;">
        <button class="leaderboard-btn" onclick="showLeaderboard()">üèÜ Leaderboard</button>
    </div>

    <!-- User Info -->
    <div class="user-info" id="userInfo" style="display: none;">
        <div>üë®‚Äçüíª <span id="userName">Loading...</span></div>
        <div style="margin-top: 5px;">
            <button class="auth-btn" onclick="logout()" style="padding: 4px 8px; font-size: 0.8em;">Logout</button>
        </div>
    </div>

    <div class="game-header">
        <h1 class="game-title">ü¶ñ‚Üíüì° XANO DASH</h1>
        <p class="game-subtitle">Improved Edition</p>
        <p class="tagline">"The only time your backend fails‚Ä¶ is when you're not using Xano."</p>
    </div>

    <canvas id="gameCanvas" width="1000" height="400"></canvas>

    <div class="controls">
        <p>üéÆ <strong>SPACE/CLICK</strong> to jump | <strong>DOWN</strong> to duck | <strong>P</strong> to pause | <strong>R</strong> to restart</p>
        <p>üèÜ Build combos by dodging! Near-miss = 2x bonus! | ‚Üë‚Üë‚Üì‚Üì‚Üê‚Üí‚Üê‚ÜíBA for Easter egg</p>
        <p>Survive the backend nightmare! Click anywhere to start!</p>
    </div>

    <div class="game-over" id="gameOver">
        <h2 style="color: #ff6b6b;">BACKEND CRASHED! üí•</h2>
        <p id="finalScore">Score: 0</p>
        <div id="scorePrompt" style="display: none; margin: 15px 0; padding: 15px; background: rgba(0, 245, 255, 0.1); border-radius: 8px; border: 1px solid #00f5ff;">
            <p style="color: #00f5ff; margin: 0 0 10px 0;">üèÜ Want to save this score to the leaderboard?</p>
            <p style="color: #4ecdc4; font-size: 0.9em; margin: 0 0 15px 0;">Sign up now to compete with other backend survivors!</p>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="showSignupModal()" style="padding: 8px 16px; background: #00f5ff; color: #000; border: none; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Sign Up</button>
                <button onclick="showLoginModal()" style="padding: 8px 16px; background: transparent; color: #4ecdc4; border: 1px solid #4ecdc4; border-radius: 5px; cursor: pointer; font-family: 'Courier New', monospace;">Login</button>
            </div>
        </div>
        <p style="color: #4ecdc4;">Maybe use Xano next time? üòâ</p>
        <button onclick="restartGame()" style="padding: 10px 20px; font-size: 1.1em; background: #00f5ff; border: none; border-radius: 5px; cursor: pointer;">Try Again</button>
    </div>

    <div class="backend-joke">
        <p><strong>Backend Status:</strong> <span style="color: #ff6b6b;">‚ùå Not Found</span></p>
        <p>"This is what happens when your app goes offline‚Ä¶ unless you're on Xano."</p>
        <p style="font-size: 0.7em; margin-top: 10px; color: #666;">
            Built using absolutely nothing you need to deploy with Xano ‚Äî 
            but you can bundle this game and serve it during downtime.
        </p>
    </div>

    <!-- Login Modal -->
    <div class="modal" id="loginModal">
        <div class="modal-content">
            <h2>üîê Login to Xano Dash</h2>
            <form id="loginForm">
                <div class="form-group">
                    <label for="loginEmail">Email:</label>
                    <input type="email" id="loginEmail" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password:</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <div id="loginError" class="error-message"></div>
                <div class="modal-buttons">
                    <button type="submit" class="modal-btn primary">Login</button>
                    <button type="button" class="modal-btn secondary" onclick="closeModal('loginModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Signup Modal -->
    <div class="modal" id="signupModal">
        <div class="modal-content">
            <h2>üöÄ Join the Backend Warriors</h2>
            <form id="signupForm">
                <div class="form-group">
                    <label for="signupName">Username:</label>
                    <input type="text" id="signupName" required>
                </div>
                <div class="form-group">
                    <label for="signupEmail">Email:</label>
                    <input type="email" id="signupEmail" required>
                </div>
                <div class="form-group">
                    <label for="signupPassword">Password:</label>
                    <input type="password" id="signupPassword" required>
                </div>
                <div id="signupError" class="error-message"></div>
                <div class="modal-buttons">
                    <button type="submit" class="modal-btn primary">Sign Up</button>
                    <button type="button" class="modal-btn secondary" onclick="closeModal('signupModal')">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="modal" id="leaderboardModal">
        <div class="modal-content">
            <h2>üèÜ Backend Nightmare Survivors</h2>
            <div id="leaderboardContent">
                <p style="text-align: center; color: #4ecdc4;">Loading leaderboard...</p>
            </div>
            <div class="modal-buttons">
                <button type="button" class="modal-btn secondary" onclick="closeModal('leaderboardModal')">Close</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Xano API Configuration
        const XANO_AUTH_API = 'https://xxmf-qrth-inat.n7d.xano.io/api:S2PDGkeW';
        const XANO_LEADERBOARD_API = 'https://xxmf-qrth-inat.n7d.xano.io/api:S2PDGkeW';
        
        // Authentication state
        let currentUser = null;
        let authToken = localStorage.getItem('xanoAuthToken');
        let currentGameId = null;
        let lastScore = 0;

        // Game state
        let gameRunning = false;
        let gamePaused = false;
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        let score = 0;
        let highScore = localStorage.getItem('xanoHighScore') || 0;
        let gameSpeed = 2.0;
        let baseGameSpeed = 2.0;
        let isRainbowMode = false;
        let konamiCode = [];
        const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
        let comboCount = 0;
        let comboMultiplier = 1;
        let lastObstacleTime = 0;
        let lastSpeedIncrease = 0;
        let gameLoopId = null;
        let nearMissCount = 0;
        let screenShake = 0;

        // Player
        const player = {
            x: 100,
            y: canvas.height - 80,
            width: 50,
            height: 50,
            jumpHeight: 0,
            jumpSpeed: 0,
            grounded: true,
            ducking: false,
            duckHeight: 25,
            doubleJump: false,
            invincible: false,
            invincibleStartTime: 0,
            invincibleDuration: 0,
            rateLimiterActive: false,
            rateLimiterStartTime: 0,
            rateLimiterDuration: 0,
            ddosActive: false,
            ddosTime: 0,
            ddosStartTime: 0,
            ddosDirection: 1
        };

        // Game objects
        let obstacles = [];
        let powerUps = [];
        let particles = [];
        let obstacleSpawnTimer = 0;
        let powerUpSpawnTimer = 0;
        let wavePattern = [];
        let currentWave = 0;

        // IMPROVED: Obstacle types with varied heights and behaviors
        const obstacleTypes = [
            // Ground obstacles
            { emoji: '‚õî', text: '502', color: '#ff6b6b', width: 35, height: 30, type: 'ground', humor: "Bad Gateway Blues" },
            { emoji: 'üó°Ô∏è', text: 'SQL', color: '#ff9f43', width: 30, height: 30, type: 'ground', humor: "Little Bobby Tables strikes again!" },
            { emoji: 'üêå', text: 'SLOW', color: '#26de81', width: 40, height: 20, type: 'ground', humor: "O(n¬≤) algorithm detected" },
            { emoji: 'üö´', text: 'CORS', color: '#fd79a8', width: 35, height: 30, type: 'ground', humor: "Access denied from localhost" },
            { emoji: 'üíæ', text: 'LOCK', color: '#00b894', width: 35, height: 30, type: 'ground', humor: "Database locked by mysterious process" },
            { emoji: 'üï≥Ô∏è', text: 'NULL', color: '#636e72', width: 30, height: 25, type: 'ground', humor: "Null pointer exception vibes" },
            { emoji: 'üîß', text: 'MAINT', color: '#00cec9', width: 40, height: 30, type: 'ground', humor: "Scheduled downtime (unscheduled panic)" },
            
            // Flying obstacles (high)
            { emoji: '‚òÅÔ∏è', text: 'CLOUD', color: '#a29bfe', width: 45, height: 25, type: 'flying-high', humor: "Cloud migration gone wrong" },
            { emoji: 'üî•', text: 'OOM', color: '#e84393', width: 30, height: 35, type: 'flying-high', humor: "Out of memory, out of luck" },
            { emoji: '‚ö°', text: 'CACHE', color: '#fdcb6e', width: 40, height: 25, type: 'flying-high', humor: "Cache miss at the worst moment" },
            
            // Flying obstacles (mid)
            { emoji: 'üå™Ô∏è', text: 'DDOS', color: '#6c5ce7', width: 35, height: 35, type: 'flying-mid', humor: "Traffic tsunami incoming!" },
            { emoji: 'üîí', text: 'RATE', color: '#e17055', width: 35, height: 30, type: 'flying-mid', humor: "Too many requests, chill out!" },
            { emoji: 'üë®‚Äçüíª', text: 'while(true)', color: '#a29bfe', width: 45, height: 30, type: 'flying-mid', humor: "Infinite loop of despair" },
        ];

        // Power-up types
        const powerUpTypes = [
            { emoji: 'üß†', text: 'Function Stack', color: '#00cec9', effect: 'invincible' },
            { emoji: '‚öôÔ∏è', text: 'Auto-Scale', color: '#6c5ce7', effect: 'doubleJump' },
            { emoji: 'üõ°Ô∏è', text: 'Rate Limiter', color: '#a29bfe', effect: 'slowDown' },
            { emoji: 'üíö', text: 'Health', color: '#00b894', effect: 'health' }
        ];

        // IMPROVED: Obstacle wave patterns for better RNG
        const wavePatterns = [
            // Single obstacles
            { count: 1, spacing: 0, types: ['ground'] },
            { count: 1, spacing: 0, types: ['flying-high'] },
            { count: 1, spacing: 0, types: ['flying-mid'] },
            
            // Double obstacles (requires jump or duck timing)
            { count: 2, spacing: 200, types: ['ground', 'ground'] },
            { count: 2, spacing: 250, types: ['flying-high', 'flying-high'] },
            
            // Mixed patterns (harder!)
            { count: 2, spacing: 150, types: ['ground', 'flying-high'] }, // Jump high
            { count: 2, spacing: 180, types: ['ground', 'flying-mid'] }, // Jump + duck
            { count: 3, spacing: 120, types: ['flying-high', 'ground', 'flying-high'] }, // Wave pattern
        ];

        function drawPlayer() {
            ctx.save();
            
            if (player.invincible) {
                ctx.globalAlpha = 0.7 + Math.sin(Date.now() * 0.01) * 0.3;
            }

            const currentHeight = player.ducking && player.grounded ? player.duckHeight : player.height;
            const currentY = player.y - player.jumpHeight + (player.ducking && player.grounded ? player.height - player.duckHeight : 0);

            const gradient = ctx.createLinearGradient(player.x, currentY, player.x + player.width, currentY + currentHeight);
            gradient.addColorStop(0, '#00f5ff');
            gradient.addColorStop(1, '#0091ff');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(player.x, currentY, player.width, currentHeight);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('XANO', player.x + player.width/2, currentY + currentHeight/2 + 4);

            if (isRainbowMode) {
                for (let i = 0; i < 10; i++) {
                    ctx.fillStyle = `hsl(${(Date.now() * 0.1 + i * 36) % 360}, 100%, 50%)`;
                    ctx.globalAlpha = 0.3 - i * 0.03;
                    ctx.fillRect(player.x - i * 5, currentY, player.width, currentHeight);
                }
            }

            ctx.restore();
        }

        function drawObstacle(obstacle) {
            ctx.fillStyle = obstacle.color;
            ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
            
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(obstacle.emoji, obstacle.x + obstacle.width/2, obstacle.y + 25);
            
            ctx.font = 'bold 10px Courier New';
            ctx.fillStyle = '#fff';
            ctx.fillText(obstacle.text, obstacle.x + obstacle.width/2, obstacle.y + obstacle.height - 5);
        }

        function drawPowerUp(powerUp) {
            const float = Math.sin(Date.now() * 0.005 + powerUp.x * 0.01) * 5;
            
            ctx.fillStyle = powerUp.color;
            ctx.fillRect(powerUp.x, powerUp.y + float, 40, 40);
            
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(powerUp.emoji, powerUp.x + 20, powerUp.y + float + 25);
        }

        function drawParticle(particle) {
            ctx.fillStyle = particle.color;
            ctx.globalAlpha = particle.life;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        // IMPROVED: Smart obstacle creation with better RNG
        function createObstacleWave() {
            const difficultyLevel = Math.floor(score / 5000);
            let availablePatterns = wavePatterns.slice(0, Math.min(3 + difficultyLevel, wavePatterns.length));
            
            const pattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
            let startX = canvas.width;

            for (let i = 0; i < pattern.count; i++) {
                const typeFilter = pattern.types[i];
                const availableTypes = obstacleTypes.filter(t => t.type === typeFilter);
                const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                
                let y;
                switch (type.type) {
                    case 'ground':
                        y = canvas.height - type.height - 30;
                        break;
                    case 'flying-high':
                        y = canvas.height - 150 - type.height;
                        break;
                    case 'flying-mid':
                        y = canvas.height - 100 - type.height;
                        break;
                }

                obstacles.push({
                    x: startX + (i * pattern.spacing),
                    y: y,
                    width: type.width,
                    height: type.height,
                    emoji: type.emoji,
                    text: type.text,
                    color: type.color,
                    type: type.type,
                    humor: type.humor,
                    passed: false
                });
            }
        }

        function createPowerUp() {
            const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            const height = 100 + Math.random() * 100; // Random height
            
            powerUps.push({
                x: canvas.width,
                y: canvas.height - height,
                emoji: type.emoji,
                text: type.text,
                color: type.color,
                effect: type.effect
            });
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    size: Math.random() * 3 + 1,
                    life: 1,
                    color: color
                });
            }
        }

        function updatePlayer() {
            const now = Date.now();
            
            if (!player.grounded) {
                player.jumpSpeed += 0.4;
                player.jumpHeight -= player.jumpSpeed;
                
                if (player.jumpHeight <= 0) {
                    player.jumpHeight = 0;
                    player.jumpSpeed = 0;
                    player.grounded = true;
                    
                    // Landing particles
                    createParticles(player.x + player.width/2, player.y, '#00f5ff', 5);
                }
            }

            if (player.invincible) {
                const elapsed = now - player.invincibleStartTime;
                if (elapsed >= player.invincibleDuration) {
                    player.invincible = false;
                }
            }

            if (player.rateLimiterActive) {
                const elapsed = now - player.rateLimiterStartTime;
                if (elapsed >= player.rateLimiterDuration) {
                    player.rateLimiterActive = false;
                    const targetSpeed = baseGameSpeed + Math.floor(score / 800) * 0.15;
                    gameSpeed = Math.min(targetSpeed, gameSpeed + 1);
                }
            }

            if (player.ddosActive) {
                const ddosElapsed = Date.now() - player.ddosStartTime;
                const ddosDuration = 10000;
                
                if (Math.random() < 0.3) {
                    player.ddosDirection = Math.random() > 0.5 ? 1 : -1;
                    player.x += player.ddosDirection * (Math.random() * 8 + 2);
                    
                    if (player.x < 50) player.x = 50;
                    if (player.x > canvas.width - 150) player.x = canvas.width - 150;
                }
                
                player.ddosTime = Math.max(0, ddosDuration - ddosElapsed);
                
                if (ddosElapsed >= ddosDuration) {
                    player.ddosActive = false;
                    player.x = 100;
                }
            }
        }

        function updateObstacles() {
            obstacles = obstacles.filter(obstacle => {
                obstacle.x -= gameSpeed;
                return obstacle.x + obstacle.width > 0;
            });

            // IMPROVED: Dynamic spawn rate based on score
            obstacleSpawnTimer += 1;
            let spawnInterval = Math.max(60, 120 - Math.floor(score / 2000) * 10); // Gets faster over time
            
            if (obstacleSpawnTimer >= spawnInterval) {
                createObstacleWave();
                obstacleSpawnTimer = 0;
            }
        }

        function updatePowerUps() {
            powerUps = powerUps.filter(powerUp => {
                powerUp.x -= gameSpeed;
                return powerUp.x + 40 > 0;
            });

            // IMPROVED: Better power-up spawn rate
            powerUpSpawnTimer += 1;
            let powerUpInterval = 500 - Math.floor(score / 5000) * 50; // More frequent at higher scores
            powerUpInterval = Math.max(200, powerUpInterval);
            
            if (powerUpSpawnTimer >= powerUpInterval && Math.random() < 0.3) {
                createPowerUp();
                powerUpSpawnTimer = 0;
            }
        }

        function updateParticles() {
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vy += 0.1; // Gravity
                particle.life -= 0.02;
                return particle.life > 0;
            });
        }

        function checkCollisions() {
            const currentHeight = player.ducking && player.grounded ? player.duckHeight : player.height;
            const currentY = player.y - player.jumpHeight + (player.ducking && player.grounded ? player.height - player.duckHeight : 0);

            obstacles.forEach((obstacle, index) => {
                // IMPROVED: Better hitbox detection with some leniency
                const hitboxMargin = 5; // Make hitboxes slightly smaller for fairness
                
                if (player.x + hitboxMargin < obstacle.x + obstacle.width - hitboxMargin &&
                    player.x + player.width - hitboxMargin > obstacle.x + hitboxMargin &&
                    currentY + hitboxMargin < obstacle.y + obstacle.height - hitboxMargin &&
                    currentY + currentHeight - hitboxMargin > obstacle.y + hitboxMargin) {
                    
                    if (!player.invincible) {
                        gameOver(obstacle.humor || "Your backend just crashed!");
                    }
                } else if (obstacle.x + obstacle.width < player.x && !obstacle.passed) {
                    obstacle.passed = true;
                    comboCount++;
                    comboMultiplier = 1 + (comboCount * 0.1);
                    lastObstacleTime = Date.now();
                    
                    // Create success particles
                    createParticles(obstacle.x, obstacle.y, obstacle.color, 8);
                }
                
                // IMPROVED: Near-miss detection for bonus points!
                if (!obstacle.nearMiss && obstacle.x < player.x + player.width + 30 && obstacle.x > player.x - 30) {
                    const verticalDistance = Math.abs((currentY + currentHeight/2) - (obstacle.y + obstacle.height/2));
                    if (verticalDistance < 80 && verticalDistance > 30) {
                        obstacle.nearMiss = true;
                        nearMissCount++;
                        score += 50 * comboMultiplier; // Bonus points!
                        screenShake = 5; // Screen shake effect
                        createParticles(player.x + player.width/2, currentY + currentHeight/2, '#ffd700', 15);
                    }
                }
            });

            powerUps = powerUps.filter(powerUp => {
                if (player.x < powerUp.x + 40 &&
                    player.x + player.width > powerUp.x &&
                    currentY < powerUp.y + 40 &&
                    currentY + currentHeight > powerUp.y) {
                    
                    activatePowerUp(powerUp.effect);
                    createParticles(powerUp.x + 20, powerUp.y + 20, powerUp.color, 20);
                    return false;
                }
                return true;
            });
        }

        function activatePowerUp(effect) {
            const now = Date.now();
            
            switch (effect) {
                case 'invincible':
                    player.invincible = true;
                    player.invincibleStartTime = now;
                    player.invincibleDuration = 5000;
                    break;
                case 'doubleJump':
                    if (!player.doubleJump) {
                        player.doubleJump = true;
                    }
                    break;
                case 'slowDown':
                    if (!player.rateLimiterActive) {
                        const minSpeed = Math.max(1.0, baseGameSpeed - 1);
                        gameSpeed = Math.max(minSpeed, gameSpeed - 1);
                        player.rateLimiterActive = true;
                        player.rateLimiterStartTime = now;
                        player.rateLimiterDuration = 3000;
                    }
                    break;
                case 'health':
                    // Health pickup - could add lives system here
                    score += 200;
                    break;
            }
        }

        function jump() {
            if (player.grounded) {
                player.jumpSpeed = -13;
                player.grounded = false;
                createParticles(player.x + player.width/2, player.y, '#00f5ff', 8);
            } else if (player.doubleJump) {
                player.jumpSpeed = -10;
                player.doubleJump = false;
                createParticles(player.x + player.width/2, player.y - player.jumpHeight, '#6c5ce7', 12);
            }
        }

        function duck(isDucking) {
            if (player.grounded) {
                player.ducking = isDucking;
            }
        }

        function gameOver(deathMessage = "Your backend just crashed!") {
            gameRunning = false;
            gamePaused = false;
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            canvas.classList.add('death-animation');
            setTimeout(() => canvas.classList.remove('death-animation'), 500);
            
            const isNewHighScore = score > highScore;
            if (isNewHighScore) {
                highScore = score;
                localStorage.setItem('xanoHighScore', highScore);
            }
            
            const finalScoreElement = document.getElementById('finalScore');
            finalScoreElement.textContent = `Score: ${score.toLocaleString()}`;
            
            if (isNewHighScore && score > 0) {
                finalScoreElement.classList.add('new-high-score');
                finalScoreElement.textContent = `üéâ NEW HIGH SCORE: ${score.toLocaleString()}! üéâ`;
            } else {
                finalScoreElement.classList.remove('new-high-score');
            }
            
            const gameOverDiv = document.getElementById('gameOver');
            const existingHumor = gameOverDiv.querySelector('.death-humor');
            if (existingHumor) {
                existingHumor.textContent = deathMessage;
            } else {
                const humorP = document.createElement('p');
                humorP.className = 'death-humor';
                humorP.style.cssText = 'color: #ff6b6b; font-style: italic; margin: 10px 0; font-size: 0.9em;';
                humorP.textContent = deathMessage;
                gameOverDiv.insertBefore(humorP, document.getElementById('scorePrompt'));
            }
            gameOverDiv.style.display = 'block';
            
            lastScore = score;
            
            const scorePrompt = document.getElementById('scorePrompt');
            if (!authToken && score > 500) {
                scorePrompt.style.display = 'block';
            } else {
                scorePrompt.style.display = 'none';
            }
            
            if (authToken && currentGameId) {
                submitScore(score, currentGameId);
                setTimeout(() => {
                    showLeaderboard();
                }, 1000);
            }
        }

        function restartGame() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            gameSpeed = baseGameSpeed;
            gameRunning = true;
            gamePaused = false;
            pauseStartTime = 0;
            totalPausedTime = 0;
            score = 0;
            obstacles = [];
            powerUps = [];
            particles = [];
            comboCount = 0;
            comboMultiplier = 1;
            lastObstacleTime = 0;
            lastSpeedIncrease = 0;
            nearMissCount = 0;
            screenShake = 0;
            obstacleSpawnTimer = 0;
            powerUpSpawnTimer = 0;
            
            player.x = 100;
            player.y = canvas.height - 80;
            player.jumpHeight = 0;
            player.jumpSpeed = 0;
            player.grounded = true;
            player.ducking = false;
            player.invincible = false;
            player.invincibleStartTime = 0;
            player.invincibleDuration = 0;
            player.doubleJump = false;
            player.rateLimiterActive = false;
            player.rateLimiterStartTime = 0;
            player.rateLimiterDuration = 0;
            player.ddosActive = false;
            player.ddosTime = 0;
            
            isRainbowMode = false;
            document.getElementById('gameOver').style.display = 'none';
            
            if (authToken) {
                createGameSession();
            }
            
            if (!gameLoopId) {
                gameLoop();
            }
        }
        
        function togglePause() {
            if (gameRunning) {
                if (!gamePaused) {
                    gamePaused = true;
                    pauseStartTime = Date.now();
                } else {
                    gamePaused = false;
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPausedTime += pauseDuration;
                    
                    if (player.invincible) {
                        player.invincibleStartTime += pauseDuration;
                    }
                    if (player.rateLimiterActive) {
                        player.rateLimiterStartTime += pauseDuration;
                    }
                    if (player.ddosActive) {
                        player.ddosStartTime += pauseDuration;
                    }
                }
            }
        }

        function drawBackground() {
            ctx.save();
            
            // Apply screen shake
            if (screenShake > 0) {
                ctx.translate(
                    Math.random() * screenShake - screenShake / 2,
                    Math.random() * screenShake - screenShake / 2
                );
                screenShake *= 0.9;
                if (screenShake < 0.1) screenShake = 0;
            }
            
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(1, '#16213e');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#333';
            ctx.fillRect(0, canvas.height - 30, canvas.width, 30);

            ctx.strokeStyle = 'rgba(0, 245, 255, 0.1)';
            ctx.lineWidth = 1;
            const gridOffset = (Date.now() * 0.05) % 50;
            for (let x = -gridOffset; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            ctx.restore();
        }

        function drawUI() {
            ctx.font = 'bold 24px Courier New';
            ctx.fillStyle = '#00f5ff';
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${score.toLocaleString()}`, 20, 40);
            
            ctx.font = '16px Courier New';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`Best: ${parseInt(highScore).toLocaleString()}`, 20, 65);

            ctx.fillStyle = '#4ecdc4';
            ctx.fillText(`Speed: ${gameSpeed.toFixed(1)}x`, 20, 90);
            
            if (comboCount > 0) {
                ctx.font = 'bold 20px Courier New';
                ctx.fillStyle = comboCount > 10 ? '#ff6b6b' : comboCount > 5 ? '#ffd700' : '#4ecdc4';
                ctx.fillText(`üî• COMBO x${comboCount} (${comboMultiplier.toFixed(1)}x)`, 20, 120);
            }

            if (nearMissCount > 0) {
                ctx.font = '16px Courier New';
                ctx.fillStyle = '#ffd700';
                ctx.fillText(`‚ö° Near-Miss x${nearMissCount}`, 20, 145);
            }

            let yOffset = 170;
            const now = Date.now();
            
            if (player.invincible) {
                const elapsed = now - player.invincibleStartTime;
                const timeLeft = Math.max(0, Math.ceil((player.invincibleDuration - elapsed) / 1000));
                ctx.font = '16px Courier New';
                ctx.fillStyle = '#00cec9';
                ctx.fillText(`üß† INVINCIBLE (${timeLeft}s)`, 20, yOffset);
                yOffset += 25;
            }
            
            if (player.doubleJump) {
                ctx.font = '16px Courier New';
                ctx.fillStyle = '#6c5ce7';
                ctx.fillText('‚öôÔ∏è DOUBLE JUMP', 20, yOffset);
                yOffset += 25;
            }
            
            if (player.rateLimiterActive) {
                const elapsed = now - player.rateLimiterStartTime;
                const timeLeft = Math.max(0, Math.ceil((player.rateLimiterDuration - elapsed) / 1000));
                ctx.font = '16px Courier New';
                ctx.fillStyle = '#a29bfe';
                ctx.fillText(`üõ°Ô∏è RATE LIMITER (${timeLeft}s)`, 20, yOffset);
                yOffset += 25;
            }
            
            if (gamePaused) {
                ctx.font = 'bold 48px Courier New';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.textAlign = 'center';
                ctx.fillText('‚è∏Ô∏è PAUSED', canvas.width/2, canvas.height/2);
                ctx.font = '20px Courier New';
                ctx.fillStyle = '#4ecdc4';
                ctx.fillText('Press P to resume | R to restart', canvas.width/2, canvas.height/2 + 50);
                ctx.textAlign = 'left';
            }
            
            if (player.ddosActive) {
                const timeLeft = Math.ceil(player.ddosTime / 1000);
                const flashOpacity = Math.sin(Date.now() * 0.02) * 0.5 + 0.5;
                ctx.globalAlpha = flashOpacity;
                ctx.font = 'bold 48px Courier New';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö†Ô∏è DDOS ATTACK! ‚ö†Ô∏è', canvas.width/2, 150);
                ctx.font = 'bold 24px Courier New';
                ctx.fillStyle = '#ff6b6b';
                ctx.fillText(`SYSTEM UNSTABLE (${timeLeft}s)`, canvas.width/2, 180);
                ctx.globalAlpha = 1;
                ctx.textAlign = 'left';
            }

            if (isRainbowMode) {
                ctx.font = 'bold 20px Courier New';
                ctx.textAlign = 'center';
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(0.16, '#ff7f00');
                gradient.addColorStop(0.33, '#ffff00');
                gradient.addColorStop(0.5, '#00ff00');
                gradient.addColorStop(0.66, '#0000ff');
                gradient.addColorStop(0.83, '#4b0082');
                gradient.addColorStop(1, '#9400d3');
                ctx.fillStyle = gradient;
                ctx.fillText('üåà XANO RECOVERY NODE ACTIVATED! üåà', canvas.width/2, 50);
            }
        }

        function gameLoop() {
            if (!gameRunning) {
                gameLoopId = null;
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();

            if (!gamePaused) {
                const expectedMaxSpeed = baseGameSpeed + Math.floor(score / 800) * 0.15 + 2;
                if (gameSpeed > expectedMaxSpeed) {
                    gameSpeed = baseGameSpeed + Math.floor(score / 800) * 0.15;
                }
                
                updatePlayer();
                updateObstacles();
                updatePowerUps();
                updateParticles();
                checkCollisions();

                const basePoints = 1;
                score += Math.floor(basePoints * comboMultiplier);
                
                if (comboCount > 0 && Date.now() - lastObstacleTime > 3000) {
                    comboCount = 0;
                    comboMultiplier = 1;
                }
                
                if (score > 0 && score % 800 === 0 && score !== lastSpeedIncrease) {
                    const expectedSpeed = baseGameSpeed + Math.floor(score / 800) * 0.15;
                    gameSpeed = expectedSpeed;
                    lastSpeedIncrease = score;
                }

                if (score === 10000 && !player.ddosActive) {
                    player.ddosActive = true;
                    player.ddosStartTime = Date.now();
                    player.ddosTime = 600;
                }
            }

            particles.forEach(drawParticle);
            obstacles.forEach(drawObstacle);
            powerUps.forEach(drawPowerUp);
            drawPlayer();
            drawUI();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            const target = e.target;
            const tagName = target && target.tagName ? target.tagName.toUpperCase() : '';
            if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT' || (target && target.isContentEditable)) {
                return;
            }
            
            if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                if (gameRunning || document.getElementById('gameOver').style.display === 'block') {
                    restartGame();
                }
                return;
            }
            
            if (e.key === 'p' || e.key === 'P') {
                e.preventDefault();
                togglePause();
                return;
            }
            
            // Duck on down arrow
            if ((e.key === 'ArrowDown' || e.key === 'Down') && gameRunning && !gamePaused) {
                e.preventDefault();
                duck(true);
            }
            
            if ((e.code === 'Space' || e.key === ' ' || e.keyCode === 32) && gameRunning && !gamePaused) {
                e.preventDefault();
                jump();
            }

            konamiCode.push(e.keyCode);
            if (konamiCode.length > konamiSequence.length) {
                konamiCode.shift();
            }
            
            if (konamiCode.length === konamiSequence.length &&
                konamiCode.every((code, index) => code === konamiSequence[index])) {
                isRainbowMode = !isRainbowMode;
                konamiCode = [];
                
                if (isRainbowMode) {
                    player.invincible = true;
                    player.invincibleStartTime = Date.now();
                    player.invincibleDuration = 10000;
                }
            }

            if ((e.code === 'Space' || e.key === ' ' || e.keyCode === 32) && !gameRunning) {
                restartGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowDown' || e.key === 'Down') {
                e.preventDefault();
                duck(false);
            }
        });

        canvas.addEventListener('click', (e) => {
            if (gameRunning && !gamePaused) {
                jump();
            } else {
                restartGame();
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameRunning && !gamePaused) {
                jump();
            } else {
                restartGame();
            }
        });
        
        // ==================== AUTHENTICATION FUNCTIONS ====================
        
        async function login(email, password) {
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ email, password })
                });
                
                const data = await response.json();
                if (response.ok) {
                    authToken = data.authToken;
                    localStorage.setItem('xanoAuthToken', authToken);
                    await getCurrentUser();
                    updateAuthUI();
                    return { success: true };
                } else {
                    return { success: false, error: data.message || 'Login failed' };
                }
            } catch (error) {
                return { success: false, error: 'Network error' };
            }
        }

        async function signup(name, email, password) {
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/signup`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ name, email, password })
                });
                
                const data = await response.json();
                if (response.ok) {
                    authToken = data.authToken;
                    localStorage.setItem('xanoAuthToken', authToken);
                    await getCurrentUser();
                    updateAuthUI();
                    return { success: true };
                } else {
                    return { success: false, error: data.message || 'Signup failed' };
                }
            } catch (error) {
                return { success: false, error: 'Network error' };
            }
        }

        async function getCurrentUser() {
            if (!authToken) return;
            
            try {
                const response = await fetch(`${XANO_AUTH_API}/auth/me`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`,
                    }
                });
                
                if (response.ok) {
                    currentUser = await response.json();
                } else {
                    logout();
                }
            } catch (error) {
                console.error('Error getting user:', error);
            }
        }

        function logout() {
            authToken = null;
            currentUser = null;
            currentGameId = null;
            localStorage.removeItem('xanoAuthToken');
            updateAuthUI();
        }

        function updateAuthUI() {
            const authSection = document.getElementById('authSection');
            const userInfo = document.getElementById('userInfo');
            const leaderboardBtnContainer = document.getElementById('leaderboardBtnContainer');
            
            if (currentUser) {
                authSection.style.display = 'none';
                userInfo.style.display = 'block';
                document.getElementById('userName').textContent = currentUser.name;
                leaderboardBtnContainer.style.top = '20px';
                
                if (lastScore > 0 && !gameRunning) {
                    submitScoreAfterAuth(lastScore);
                    lastScore = 0;
                }
            } else {
                authSection.style.display = 'flex';
                userInfo.style.display = 'none';
                leaderboardBtnContainer.style.top = '70px';
            }
        }

        // ==================== LEADERBOARD FUNCTIONS ====================

        async function createGameSession() {
            if (!authToken) return;
            
            try {
                const response = await fetch(`${XANO_LEADERBOARD_API}/game`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    currentGameId = data.id;
                }
            } catch (error) {
                console.error('Error creating game session:', error);
            }
        }

        async function submitScore(playerScore, gameId) {
            if (!authToken || !gameId) return;
            
            try {
                const response = await fetch(`${XANO_LEADERBOARD_API}/score`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`,
                    },
                    body: JSON.stringify({
                        score: playerScore,
                        game_id: gameId
                    })
                });
                
                if (response.ok) {
                    console.log('Score submitted successfully!');
                }
            } catch (error) {
                console.error('Error submitting score:', error);
            }
        }

        async function submitScoreAfterAuth(playerScore) {
            try {
                const gameResponse = await fetch(`${XANO_LEADERBOARD_API}/game`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (gameResponse.ok) {
                    const gameData = await gameResponse.json();
                    await submitScore(playerScore, gameData.id);
                    alert(`üéâ Score ${playerScore.toLocaleString()} saved to leaderboard!`);
                    document.getElementById('scorePrompt').style.display = 'none';
                }
            } catch (error) {
                console.error('Error submitting score after auth:', error);
            }
        }

        async function getLeaderboard() {
            try {
                const response = await fetch(`${XANO_LEADERBOARD_API}/leaderboards`);
                
                if (response.ok) {
                    const data = await response.json();
                    return data.items || [];
                } else {
                    return [];
                }
            } catch (error) {
                console.error('Error getting leaderboard:', error);
                return [];
            }
        }

        // ==================== MODAL FUNCTIONS ====================

        function showLoginModal() {
            document.getElementById('loginModal').style.display = 'flex';
        }

        function showSignupModal() {
            document.getElementById('signupModal').style.display = 'flex';
        }

        async function showLeaderboard() {
            const modal = document.getElementById('leaderboardModal');
            const content = document.getElementById('leaderboardContent');
            
            modal.style.display = 'flex';
            content.innerHTML = '<div class="loading-text"><div class="loading-spinner"></div>Loading backend survivors...</div>';
            
            const leaderboard = await getLeaderboard();
            
            if (leaderboard.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #ff6b6b;">No scores yet! Be the first to survive the backend nightmare!</p>';
                return;
            }
            
            let html = `
                <table class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Developer</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            leaderboard.forEach((entry, index) => {
                const rank = index + 1;
                const rankEmoji = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `#${rank}`;
                html += `
                    <tr>
                        <td>${rankEmoji}</td>
                        <td>${entry.user ? entry.user.name : 'Anonymous'}</td>
                        <td>${entry.score.toLocaleString()}</td>
                    </tr>
                `;
            });
            
            html += `
                    </tbody>
                </table>
            `;
            
            content.innerHTML = html;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // ==================== FORM HANDLERS ====================

        document.getElementById('loginForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const errorDiv = document.getElementById('loginError');
            const submitButton = e.target.querySelector('button[type="submit"]');
            
            errorDiv.textContent = '';
            const originalText = submitButton.textContent;
            submitButton.innerHTML = '<div class="loading-spinner"></div>Logging in...';
            submitButton.disabled = true;
            
            const result = await login(email, password);
            
            submitButton.textContent = originalText;
            submitButton.disabled = false;
            
            if (result.success) {
                closeModal('loginModal');
                document.getElementById('loginForm').reset();
            } else {
                errorDiv.textContent = result.error;
            }
        });

        document.getElementById('signupForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('signupName').value;
            const email = document.getElementById('signupEmail').value;
            const password = document.getElementById('signupPassword').value;
            const errorDiv = document.getElementById('signupError');
            const submitButton = e.target.querySelector('button[type="submit"]');
            
            errorDiv.textContent = '';
            const originalText = submitButton.textContent;
            submitButton.innerHTML = '<div class="loading-spinner"></div>Creating account...';
            submitButton.disabled = true;
            
            const result = await signup(name, email, password);
            
            submitButton.textContent = originalText;
            submitButton.disabled = false;
            
            if (result.success) {
                closeModal('signupModal');
                document.getElementById('signupForm').reset();
            } else {
                errorDiv.textContent = result.error;
            }
        });

        // ==================== INITIALIZATION ====================

        if (authToken) {
            getCurrentUser().then(() => {
                updateAuthUI();
            });
        }

        drawBackground();
        drawUI();
        ctx.font = 'bold 32px Courier New';
        ctx.fillStyle = '#00f5ff';
        ctx.textAlign = 'center';
        ctx.fillText('CLICK TO START', canvas.width/2, canvas.height/2);
        ctx.font = '16px Courier New';
        ctx.fillStyle = '#4ecdc4';
        ctx.fillText('Survive the backend nightmare!', canvas.width/2, canvas.height/2 + 40);
        ctx.fillText('(Space to jump, Down to duck)', canvas.width/2, canvas.height/2 + 60);
    </script>
</body>
</html>

